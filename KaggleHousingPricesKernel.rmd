---
title: "Predicting the housing market in Iowa: scanning extreme gradient boosting for superior prediction"
author: "Ozan Aygun"
date: "11/26/2017"
output: 
   html_document:
        toc: true
        number_sections: true
        depth: 4
        theme: cerulean
        highlight: tango
        df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(results = "markup", fig.align = "center",
                      fig.width = 5, fig.height = 4,message=FALSE,warning=FALSE)
```


# Introduction and summary

Here I used the Ames housing data set to perform a fairly comprehensive analysis and predictive modeling to estimate house prices. I have extensively explored the training set, then performed feature engineering, missing value imputation and feature selection using the training set. Finally, I trained both linear models such as lasso regularization, PCA regression, as well as more complex algorithms including gradient boosting, extreme gradient boosting, random forest, and support vector machines. I have obtained a model that predicts house sale prices fairly well, with a RMSE of 0.12717 obtained from the test data set.

# Loading the data

```{r}
train <- read.csv("train.csv"); test <- read.csv("test.csv")
```

# Summarizing the data

Here, I will briefly look at the data just to get familiar with the features, missing values and anything strange in general.

The outcome variable SalePrice is a complete variable, but there are a number of predictors with many missing values. It looks like we will need to deal with quite a few missing values. Median house price is $163,000.

```{r}
summary(train)
```



```{r}
par(mfrow = c(1,2))
boxplot(train$SalePrice,main = "SalePrice")
boxplot(log10(train$SalePrice), main = "Log10(SalePrice)")
library(pls)
```

## Understanding the impact of missing data

Which features have more than 30% missing data?

```{r}
na.status <- is.na(train)
na.sum <- apply(na.status,2,sum)
names(na.sum) <- colnames(train)
mostly_missing <- which(na.sum > (0.3 * nrow(train)))
na.sum[mostly_missing]
```

5 variables have substantial amount of missing data. Do they have impact on the house prices?

###Alley

Based on the data description: Type of alley access to property

       Grvl     Gravel
       Pave     Paved
       NA       No alley access
       
```{r}
library(ggplot2)

ggplot(data = train, aes(x = Alley, y = log(SalePrice), fill= Alley))+
        geom_boxplot()
```
Alley might be important. Gravel homes have significantly lower price. Convert NAs to "NoAlley" to make more sense.

```{r}
train$Alley <- as.character(train$Alley)
train$Alley[which(is.na(train$Alley))] <- "NoAlley"
train$Alley <- factor(train$Alley)

#Also transform the test set
test$Alley <- as.character(test$Alley)
test$Alley[which(is.na(test$Alley))] <- "NoAlley"
test$Alley <- factor(test$Alley)
```

###FireplaceQu

Based on the data description:

FireplaceQu: Fireplace quality

       Ex       Excellent - Exceptional Masonry Fireplace
       Gd       Good - Masonry Fireplace in main level
       TA       Average - Prefabricated Fireplace in main living area or Masonry Fireplace in basement
       Fa       Fair - Prefabricated Fireplace in basement
       Po       Poor - Ben Franklin Stove
       NA       No Fireplace

```{r}

ggplot(data = train, aes(x = FireplaceQu, y = log10(SalePrice), fill= FireplaceQu))+
        geom_boxplot()

```

Let's look at through a simple linear model:

```{r}
par(mfrow=c(1,2))
hist(train$SalePrice)
hist(log10(train$SalePrice)) # Looks more gaussian



FirePlaceFit <- lm(log10(train$SalePrice) ~ FireplaceQu, data = train)
summary(FirePlaceFit)
par(mfrow=c(2,2))
plot(FirePlaceFit)
```
It appears that all levels of this feature also have significantly different mean Sales prices. Again, converting NAs to NoFireplace to be more informative.

```{r}
train$FireplaceQu <- as.character(train$FireplaceQu)
train$FireplaceQu[which(is.na(train$FireplaceQu))] <- "NoFireplace"
train$FireplaceQu <- factor(train$FireplaceQu)

#Also transform the test set
test$FireplaceQu <- as.character(test$FireplaceQu)
test$FireplaceQu[which(is.na(test$FireplaceQu))] <- "NoFireplace"
test$FireplaceQu <- factor(test$FireplaceQu)
```

###PoolQC

Based on the data description:

        PoolQC: Pool quality
               Ex       Excellent
               Gd       Good
               TA       Average/Typical
               Fa       Fair
               NA       No Pool
       
```{r}       
library(ggplot2)
ggplot(data = train, aes(x = PoolQC, y = log10(SalePrice), fill = PoolQC))+
        geom_boxplot()

```

Note that actually very few houses have pools. Houses with excellent pool condition have significantly higher sales prices. We will also keep this feature, converting NAs to "NoPool":

```{r}
train$PoolQC <- as.character(train$PoolQC)
train$PoolQC[which(is.na(train$PoolQC))] <- "NoPool"
train$PoolQC <- factor(train$PoolQC)

#Also transform the test set
test$PoolQC <- as.character(test$PoolQC)
test$PoolQC[which(is.na(test$PoolQC))] <- "NoPool"
test$PoolQC <- factor(test$PoolQC)
```

###Fence

Based on the data description:

        Fence: Fence quality
               GdPrv    Good Privacy
               MnPrv    Minimum Privacy
               GdWo     Good Wood
               MnWw     Minimum Wood/Wire
               NA       No Fence 
   
```{r}
library(ggplot2)
ggplot(data = train, aes(x = Fence, y = log10(SalePrice), fill = Fence))+
        geom_boxplot()

FenceFit <- lm(log10(train$SalePrice) ~ Fence, data = train)
summary(FenceFit)

```

Interestingly, this feature might have a complex relationship, if any at all, with the response variable. The effects of each of the level deemed as significant, so we will keep this feature at this point as well.

```{r}
train$Fence <- as.character(train$Fence)
train$Fence[which(is.na(train$Fence))] <- "NoFence"
train$Fence <- factor(train$Fence)

#Also transform the test set
test$Fence <- as.character(test$Fence)
test$Fence[which(is.na(test$Fence))] <- "NoFence"
test$Fence <- factor(test$Fence)
```

###MiscFeature

Based on the data description:

        MiscFeature: Miscellaneous feature not covered in other categories
               Elev     Elevator
               Gar2     2nd Garage (if not described in garage section)
               Othr     Other
               Shed     Shed (over 100 SF)
               TenC     Tennis Court
               NA       None
               
We will deal with the remaining missing value containing features in the next stages of our analysis.

```{r}
table(train$MiscFeature)
ggplot(data = train, aes(x = MiscFeature, y = log10(SalePrice), fill = MiscFeature))+
        geom_boxplot()
```
Again, very few houses have this features, and not sure if these qualities have a real impact on the house value amongst other measured features. Nevertheless, I will maintain this feature as well. Just converting NAs to "NoMiscFeature" to be more clear:

```{r}
train$MiscFeature <- as.character(train$MiscFeature)
train$MiscFeature[which(is.na(train$MiscFeature))] <- "NoMiscFeature"
train$MiscFeature <- factor(train$MiscFeature)

#Also transform the test set
test$MiscFeature <- as.character(test$MiscFeature)
test$MiscFeature[which(is.na(test$MiscFeature))] <- "NoMiscFeature"
test$MiscFeature <- factor(test$MiscFeature)
```

#Developing expectations from data

Here I will explore the data further, in order to develop a better understanding about the relationships between features and the home prices.

## Continuous features: watching for strong predictors and potential collinearities 

Let's look at the continuous features in the data set:

```{r, fig.align='center'}
cont.var <-NULL
for(i in 1:ncol(train)){
        if(class(train[,i]) == "integer" | class(train[,i]) == "numeric"){
                cont.var <- c(cont.var,i)
        }
}
```

###Part1: transforming LotArea to make it more gaussian

```{r,fig.width=12,fig.height=12}
pairs(log10(train$SalePrice) ~ ., data = train[,cont.var[1:10]], cex = 0.05, pch = 19, col = "navy")
```

- We need to remove ID, since this is just an identifier for the houses, has no predictive value as expected.
- OverallQual and OverallCond look strong predictors, but might have some collinearity.
- Yearbuilt and YearRemodAdd also look good predictors but most likely contain redundant information.
- For the LOT and SF features, it could be better to look at after log transformation, since the data looks skewed.

```{r,fig.width=6,fig.height=6}
par(mfrow=c(3,2))
hist(train$LotArea, breaks = 50, col = "navy");hist(log10(train$LotArea+1),breaks=50,col = "navy")
hist(train$MasVnrArea, breaks = 50,col = "navy");hist(log10(train$MasVnrArea+1),breaks=50,col = "navy")
hist(train$BsmtFinSF1, breaks = 50,col = "navy");hist(log10(train$BsmtFinSF1+1),breaks=50,col = "navy")
```

Indeed one of these features (LotArea) look more Gaussian when it is log10 transformed. 

```{r,fig.width=6,fig.height=6}
pairs(log10(train$SalePrice) ~ log10(train$LotArea+1) + log10(train$MasVnrArea+1) + log10(train$BsmtFinSF1+1),cex = 0.1, pch = 19, col = "navy")
```

When transformed, lotArea seems to do a better job in explaining the variability in the SalePrice, other 2 variables however, have substantial 0 values and it is questionable how much this transformation might help.

Therefore, I will only transform the LotArea at this stage and leave the other features as they are, for feature selection steps.



###Part2: Area related features generally explain variation in the SalePrice

```{r,fig.width=12,fig.height=12}
pairs(log10(train$SalePrice) ~ ., data = train[,cont.var[11:20]], cex = 0.05, pch = 19, col = "navy")
```

###Part3: Size of the garage and number of rooms are good predictors

```{r,fig.width=12,fig.height=12}
pairs(log10(train$SalePrice) ~ ., data = train[,cont.var[22:31]], cex = 0.05, pch = 19, col = "navy")
```

Arguably, these features are all related to the overall area of the house.

###Part4: fairly weak predictors

```{r,fig.width=12,fig.height=12}
pairs(log10(train$SalePrice) ~ ., data = train[,cont.var[32:38]], cex = 0.05, pch = 19, col = "navy")
```

Processing the identified features:
```{r}
# Remove ID variable

train.ID <- train$Id #Hold it in a new variable
train <- train[, -1]

library(dplyr)

train <- dplyr::mutate(train, log10.LotArea = log10(LotArea))
train <- dplyr::select(train, -LotArea)

# Also transform in the test set
test <- dplyr::mutate(test, log10.LotArea = log10(LotArea))
test <- dplyr::select(test, -LotArea)

```

## Categorical predictors: feature engineering to create dummy variables

Now let's look at the categorical variables to see if certain ones are more powerful than others:

```{r}
cat.var <-NULL
for(i in 1:ncol(train)){
        if(class(train[,i]) == "factor"){
                cat.var <- c(cat.var,i)
        }
}
length(cat.var)
```

We have 43 categorical variables, some of them have only few levels. This is a challenge in many ways. It is not feasible to look each of them individually, therefore, we will first convert them to binary variables and try to use regularization or decision tree-based approaches to select and use most useful features.

```{r}
# Write a function that gets a data set and converts all factor variables to dummy variables
convert.to.dummy <- function(data.set){
        cat.var <-NULL
        temp.data <- data.frame(1:nrow(data.set))
           for(i in 1:ncol(data.set)){
                if(class(data.set[,i]) == "factor"){
                        cat.var <- c(cat.var,i)
                        factor.levels <- levels(data.set[,i]) # Try to find a way to classify NA's as "NO" otherwise they generate problem downstream
                                # First check if there is any 'NA-level'
                                if(any(is.na(data.set[,i]))){
                                        dummy.vector = ifelse(is.na(data.set[,i]),1,0)
                                        dummy.vector <- data.frame(dummy.vector)
                                        colnames(dummy.vector)[1] = paste("NO",names((data.set)[i]),sep = ".")
                                        temp.data <- cbind(temp.data,dummy.vector)
                                }
                        
                                for(j in seq_along(factor.levels)){ # Then deal with normal factor levels
                                dummy.vector = ifelse(data.set[,i] == factor.levels[j],1,0)
                                
                                #Since we already dealt with NAs above
                                if(any(is.na(dummy.vector))){dummy.vector[is.na(dummy.vector)] <- 0} 
                                
                                dummy.vector <- data.frame(dummy.vector)
                                colnames(dummy.vector)[1] = paste(names((data.set)[i]),
                                                                  factor.levels[j],sep = ".")
                                temp.data <- cbind(temp.data,dummy.vector)
                                }
                }
           }
           #Remove the original categorical variables from data.set
           data.set <- data.set[,-cat.var]     
           #Add the dummy.variable set
           temp.data <- temp.data[,-1] # remove the unnecessary column
           data.set <- cbind(data.set,temp.data)
           
           return(data.set)     
}

# Keep test.IDs aside
test.ID <- test$Id

# Process the training set
training.processed <- convert.to.dummy(train)

# Process the test set
test.processed <- convert.to.dummy(test)

# Note that not all the levels are present in the test set, therefore we need to make the features same.
training.processed.SalePrice <- training.processed$SalePrice #Keep the original outcome variable 

consensus.features1 <- which(colnames(training.processed) %in% colnames(test.processed))
training.processed <- training.processed[,consensus.features1] #Keep the same features as in the test set

consensus.features2 <- which(colnames(test.processed) %in% colnames(training.processed))
test.processed <- test.processed[,consensus.features2] #Keep the same features as in the training set

identical(colnames(test.processed), colnames(training.processed))
# Same features in both sets!

training.processed <- data.frame(Log.SalePrice = log(training.processed.SalePrice),training.processed) # Add the Log of the response variable
test.processed <- data.frame(ID = test.ID,test.processed) # Add the ID variable

```

## Missing value imputation

We still have missing values in some of our features, which will be a problem down the road. 

```{r}

apply(is.na(training.processed), 2, sum)[apply(is.na(training.processed), 2, sum) != 0]

```
```{r}

apply(is.na(test.processed), 2, sum)[apply(is.na(test.processed), 2, sum) != 0]

```


##GarageYrBlt

We have 81 missing cases in our training set, these are the houses actually they don't have a garage.

```{r}
plot(y =training.processed$Log.SalePrice, x =training.processed$GarageYrBlt, pch = 19, col = "navy", cex = 0.5)
```

It looks like this feature has some relationship with the outcome, as also we can generally expect that newer houses are going to be more expensive. Therefore, we should make an attempt to impute the values missing from this feature.

```{r}
plot(training.processed$YearBuilt, training.processed$GarageYrBlt, pch = 19, col = "navy", cex = 0.5)
```

As we expected, for most of the houses the year that garage was built is the same as the year the house was built. Therefore, for imputation purpose it is sensible to use the YearBuilt feature to fill these missing values in the GarageYrBuilt feature. While this is not consistent with the fact that these houses do not contain any garage, since we captured that in the categorical features we engineered, at this point imputing the years seems to be more appropriate than removing these data points altogether:

```{r}
#Impute in the training set
training.processed$GarageYrBlt[is.na(training.processed$GarageYrBlt)] <- training.processed$YearBuilt[is.na(training.processed$GarageYrBlt)]


#Impute in the test set
test.processed$GarageYrBlt[is.na(test.processed$GarageYrBlt)] <- test.processed$YearBuilt[is.na(test.processed$GarageYrBlt)]

```

##LotFrontage

Let's look at this feature more closely:

```{r}
plot(x = training.processed$LotFrontage, y = training.processed$Log.SalePrice, cex = 0.5, col = "navy" , pch = 19)
abline(lm(training.processed$Log.SalePrice ~ training.processed$LotFrontage))
```

Again this feature seems to have some degree of relationship with the response. We suspect that this feature has relationship with other features that relate to the Lot or the general area of the house:

```{r}
cor(training.processed$LotFrontage,training.processed$log10.LotArea, use = "complete.obs")
cor(training.processed$LotFrontage,training.processed$GarageArea, use = "complete.obs")
cor(training.processed$LotFrontage,training.processed$MasVnrArea, use = "complete.obs")

# Note that correlation gets better when log10 transformed:
cor(log10(training.processed$LotFrontage), training.processed$log10.LotArea, use = "complete.obs")

summary(lm(training.processed$Log.SalePrice ~ log10(training.processed$LotFrontage) + training.processed$log10.LotArea ))

plot(y = log10(training.processed$LotFrontage), x = training.processed$log10.LotArea, cex = 0.5, col = "navy" , pch = 19)
abline(lm(log10(training.processed$LotFrontage) ~ training.processed$log10.LotArea))
```
It looks like this feature pretty much collinear with the LotArea feature, especially when log10 transformed. Therefore, we will remove this feature from both training and test data sets.

```{r}
training.processed <- dplyr::select(training.processed, -LotFrontage)
test.processed <- dplyr::select(test.processed, -LotFrontage)
```

##MasVnrArea: Masonry veneer area in square feet

Looking at more closely to this feature:

```{r}
plot(x = training.processed$MasVnrArea, y = training.processed$Log.SalePrice,cex = 0.5, col = "navy" , pch = 19)

```
Note that a large number of these values are zero, which probably reflects the houses with no masonry veener. What happens if we put these aside and look at the rest of the values:

```{r}
plot(x = log10(training.processed$MasVnrArea[training.processed$MasVnrArea != 0]), y = training.processed$Log.SalePrice[training.processed$MasVnrArea != 0],cex = 0.5, col = "navy" , pch = 19)
```

There might be 'some' relationship with the response, if not too strong. It is also a little confusing since the variable MasVnrType only has these 8 values as "none", but linked the large amount of MasVnrAre == 0 data to certain MasVnrTypes:


```{r}
qplot(data = training.processed,x = log10(training.processed$MasVnrArea), y = training.processed$Log.SalePrice, col = train$MasVnrType)
     
```

It is more clear now. The "none" group indeed represent the MasVnrArea = 0, NAs however appear as missing values in both cases.

```{r}
ggplot(data = training.processed,aes(x = train$MasVnrType, y = training.processed$Log.SalePrice, fill = train$MasVnrType))+geom_boxplot()
```
We note that the SalePrice of the missing cases in the training set is closest to the SalePrice of the houses with Stone Masonry Veener type. It is likely that the area of the veener in some of these houses were not measured, perhaps it is more difficult to do so. This is our assumption.

Based on this assumption, we will merge the NA cases with the Stone group and remove the MasVnrArea feature in both training and test data sets:

```{r}
training.processed$MasVnrType.None[training.processed$NO.MasVnrType == 1] <- 1
training.processed <- dplyr::select(training.processed, -NO.MasVnrType, -MasVnrArea)

test.processed$MasVnrType.None[test.processed$NO.MasVnrType == 1] <- 1
test.processed <- dplyr::select(test.processed, -NO.MasVnrType, -MasVnrArea)
```


## Missing data remaining in the test set

We still need to deal with few missing data points we have in the test set. Since we need to make SalePrice predictions for each of these cases, we need to assess how we can impute these values at this point:

```{r}
apply(is.na(test.processed), 2, sum)[apply(is.na(test.processed), 2, sum) != 0]
```

Some features regarding Basement and Garage have missing values:

```{r}
test.processed[which(apply(is.na(test.processed), 1, sum) != 0),which(apply(is.na(test.processed), 2, sum) != 0 )]
```

Fortunately, the missing values are only restricted to 3 house records. It is likely these unusual houses are either lacking basement or garage. Since all these features are numeric, we will simply place zero instead of NA's for these values. This is of course based on our assumption.

```{r}
for (i in 1:ncol(test.processed)) {
        if(any(is.na(test.processed[,i]))){
                test.processed[is.na(test.processed[,i]),i] <- 0
        }
}
```


This completes missing value imputation as no missing values left in either training and test data sets.

#Training predictive algorithms for estimating house prices

##Using shrinkage methods (regularization)

It would be  interesting to perform a linear model selection and see how well it might perform with the new training set we obtained.

### Fitting a lasso regression model to data

```{r}

library(glmnet)

# We create a matrix of predictors
x.training = model.matrix(Log.SalePrice ~ . -1, data = training.processed)
x.testing = model.matrix( ~ . -1, data = test.processed)

y = training.processed$Log.SalePrice

# Fit lasso regression to training data
fit.lasso <- glmnet(x.training,y, family = "gaussian")
plot(fit.lasso, xvar = "lambda", label = TRUE)
plot(fit.lasso, xvar = "dev", label = TRUE)

```


Lasso is a nice way of reducing the features while still trying to explain the variance and therefore trying to win the bias-variance trade-off. In this case we notice that only 3 features are able to explain 60% of the deviance, while adding 13 features is able to explain 80% of it. It is more feasible to use the restricted model with the few features and their shrunken coefficients.

###Choosing the optimal lambda by using cross-validation

It is best to choose the optimal lambda using cross-validation, with the aim of minimizing **mean squared error:**:

```{r}
#cv.lasso will be the list containing the coefficients and information of our optimal model fit using cross-validation (10 fold by default)
set.seed(123)
cv.lasso <- cv.glmnet(x.training,y, family = "gaussian")
plot(cv.lasso)

```

Notice that what we are doing here is actually computationally intense.

1. We get very fine grids of lambda values.
2. Using each lambda value, we perform 10-fold cross validation:

- We fit a model using the Sum of Squares convex optimization and obtain cross-validated error (average of 10 model fits)

3. We continue steps 1 and 2 for all fine grids of lambda values in the range.

The two vertical lines are produced in the plot, the left one marks the model with min error and the middle one shows a little more restricted model 1 standard error away from the minimum error.

**When choosing the optimal model, we might prefer to get the more restricted model that is indicated by the second vertical line, which is default in glmnet package, due to the 1 standard error conversion.**

The final (optimal) model coefficients we obtained by cross-validation and the non-zero features remaining:

```{r}
head(coef(cv.lasso))
```

Note that our final model includes ~30 features with non-zero coefficients. We therefore significantly reduced the size of the data set by selecting features through lasso regression. The resulting model explains more than 80% of the deviance in the outcome, which is considerable good for the training set.

We also note that some of the dummy variables remained in the model, while majority of them removed. It seems to be good idea to keep all levels as separate dummy variables until the regularization, since we don't know which ones may be important in the final model context.

###Making predictions using the best lasso model fit

Let's first start with the training set:

```{r, fig.align='center', fig.width=4, fig.height=4}
pred <- predict(cv.lasso, newx = x.training)

#Let's write a function to streamline our analyses of the various models we will train:

log.rmse.training <- function(pred,observed,method){

#pred: vector of predicted values (in log scale)
#observed: vector of observed values (in log scale)
#method: the method name used to built the predictive model        
        
#Calculating the root mean squared error:
rmse.training = sqrt(mean((pred - observed)^2))

#Calculating the Pearson correlation:
cor.training = cor(training.processed$Log.SalePrice,pred)

plot(x = pred, y = observed, cex = 0.5, col = "navy", pch = 19, 
     main = method,xlab = "Log(Predicted)", ylab = "Log(Observed)")
text(x = max(pred), y = min(observed)+0.4,
     labels = paste0("RMSE: ",rmse.training))
text(x = max(pred), y = min(observed)+0.2,
     labels = paste0("Pr.cor: ",cor.training))
}

log.rmse.training(pred = pred, observed = training.processed$Log.SalePrice, method = "Lasso")
```

Therefore, the RMSE we obtained from the training set is ~15%. 

Next we will try to use test set to estimate the house prices using our model.

###Predictions using the test set

Now we will prepare our predictions for submission:

```{r}
# These steps are needed otherwise predict() will complain!
x.testing <- data.frame(x.testing)  # Convert test matrix to data frame
x.testing$Log.SalePrice <- NULL  # Set the response to NULL (otherwise model object will keep looking at it and can't find one from the test set, throws error)

# Finally retain only the features that exists in the training data matrix
x.testing <- x.testing[,which(colnames(x.testing) %in% colnames(x.training))]

pred.lasso <- predict(cv.lasso, newx = data.matrix(x.testing))

# Note that these are predictions in log scale, we need to exponentiate them to get actual SalePrice predictions in the right scale;

pred.lasso <- exp(pred.lasso)

```

We can write a function to streamline our submissions:

```{r}
prepare.submission <- function(id,pred,method){
#pred: vector of predicted values from the test set (in linear scale)
#id: vector of indices in the test set
#method: the method name used to built the predictive model  
prediction.table <- data.frame(Id = id,SalePrice =  pred)
colnames(prediction.table)[2] <- "SalePrice"
write.csv(prediction.table,paste0(method,"_predictions",".csv"), row.names = F)
}
```

Finally, prepare our submission:
```{r,eval=FALSE}
prepare.submission(id = test.ID, pred = pred.lasso, method = "Lasso")
```

The lasso model gave us a log RMSE of 0.15597, which is very close to the error we observed in the training set.

##Using Principal Components for regression: beating the curse of dimensionality

###Dimension reduction with the training set

```{r}
library(caret)
#First get a PCA processing object
prePCA <- preProcess(training.processed[,-1],method = "pca")
#Generate the principal components from the training set 
PCAtraining <- predict(prePCA,newdata = training.processed)
dim(PCAtraining)
# Note that we reduced the data set into 171 features(principal components)


qplot(x = PC1, y = Log.SalePrice, data = PCAtraining,  alpha = I(0.3))+theme_bw()
qplot(x = PC2, y = Log.SalePrice, data = PCAtraining,  alpha = I(0.3))+theme_bw()
qplot(x = PC3, y = Log.SalePrice, data = PCAtraining,  alpha = I(0.3))+theme_bw()
qplot(x = PC4, y= Log.SalePrice, data = PCAtraining,  alpha = I(0.3))+theme_bw()
```

Now let's wee if we can further reduce the dimensions. Looking into how much variation we can cumulatively explain by principal components:

```{r}
var.vector <- apply(PCAtraining[-1], 2, var)
var.cumulative.percent <- NULL
for(i in 1:length(var.vector)){
        var.cumulative.percent[i] <- sum(var.vector[1:i])/sum(var.vector[1:length(var.vector)])*100
}
plot(y = var.cumulative.percent, x = 1:length(var.cumulative.percent), pch= 19, cex = 0.5, 
     col = "navy", ylab = "% variance explained", xlab = "# of PCs")

```

It looks like about the first 100% PCs able to explain the 80% variance in the entire data set. This is still quite large number of dimensions.

Let's follow the RMSE estimated by cross-validation in the training set if we happen to train regression models using these features:

We will use the **pcr** function in the **pls** library to perform Principal Components Regression:

```{r,cache=TRUE}
library(pls)
set.seed(2)
pcr.fit <- pcr(Log.SalePrice ~ . , data = training.processed, scale = FALSE, validation = "CV", ncomp = 170)
```

- validation = "CV" : we ask the pcr function to compute a 10-fold cross-validation error for each possible value of the principal components (M) that can be derived from the data matrix.

summary function is used to visualize the resulting model.fit object:

```{r}
summary(pcr.fit)
```

This output pretty much explains what is going on when we perform the PCR:

**In the first section of the summary table we get the CV-estimated error:**

- RMSEP: Note that pcr returns the root mean squared error (to get MSE, just square the RMSE values). For each number of components used in the model, the predicted RMSE from 10-fold CV is provided. 0-component model corresponds to the NULL model which just contains an intercept.

We can use the **validationplot()** function to plot the cross-validation estimated RMSE or MSE scores:


```{r}
validationplot(pcr.fit,val.type = "RMSEP")
```

We note that after ~25 PCs, the RMSE is stabilized around 0.16 and adding more components beyond has minimal impact. This training RMSE is not better than what we obtained from Lasso regression. 

## Training Random Forest algorithm with cross validation

Let's train RF algorithm to see if we can get a better RMSE:

```{r,cache=TRUE}
set.seed(123)
RF <- train(Log.SalePrice ~ ., data = training.processed,method = "rf", trControl = trainControl(method = "cv", number = 10)) 
RF
```

It looks like we had some major improvement in training RMSE using the RF algorithm: 

```{r}
log.rmse.training(pred = predict(RF,training.processed),observed = training.processed$Log.SalePrice,method = " Random Forest")
```

###Variable importance in Random Forest

```{r}
imp <- data.frame(RF$finalModel$importance)
imp[2] <- row.names(imp)
imp <- dplyr::arrange(imp,IncNodePurity)
head(imp,10)
```

### Evaluate the Random Forest RMSE in test data set

```{r}
pred.rf <- exp(predict(RF, newdata = test.processed)) #Note we exponentiate the predicted values to get back into linear scale
```

Finally, prepare our submission:
```{r,eval=FALSE}
prepare.submission(id = test.ID, pred = pred.rf, method = "RandomForest")
```

RF predictions gave us a RMSE of 0.14117 from the test data set, which is better than lasso, but same as SVM prediction.

## Gradient boosting with cross validation

```{r,cache=TRUE}
set.seed(123)
GBM <- train(Log.SalePrice ~ ., data = training.processed,method = "gbm", trControl = trainControl(method = "cv", number = 10), verbose = FALSE) 
GBM
```

Gradient boosting provided a model with a further improved RMSE beyond lasso.

```{r}
log.rmse.training(pred = predict(GBM,training.processed),observed = training.processed$Log.SalePrice,method = " Gradient Boosting")
```


###Variable importance in Gradient Boosting:

```{r}
dotPlot(varImp(GBM))
```

It is interesting to note that gradient boosting found OverallQual feature as the most important, as we previously noticed. Also important to note that continuous features appear as more important predictors in regression. 


### Evaluate the Gradient Boosting RMSE in test data set

```{r}
pred.gbm <- exp(predict(GBM, newdata = test.processed)) #Note we exponentiate the predicted values to get back into linear scale
```

Finally, prepare our submission:
```{r,eval=FALSE}
prepare.submission(id = test.ID, pred = pred.gbm, method = "GBM")
```

GBM prediction gave us a RMSE of 0.12764 in the test data set, which is higher than lasso, RF or SVM.

## Extreme gradient boosting with cross validation

```{r,cache=TRUE}
set.seed(123)
xGB <- train(Log.SalePrice ~ ., data = training.processed,method = "xgbLinear", trControl = trainControl(method = "cv", number = 10), verbose = FALSE) 
xGB
```

Extreme Gradient boosting provided a model with a training RMSE of 0.029, which is quite good!

```{r}
log.rmse.training(pred = predict(xGB,training.processed),observed = training.processed$Log.SalePrice,method = "Extreme Gradient Boosting")
```
### Evaluate the Gradient Boosting RMSE in test data set

```{r}
pred.xgb <- exp(predict(xGB, newdata = test.processed)) #Note we exponentiate the predicted values to get back into linear scale
```

Finally, prepare our submission:
```{r,eval=FALSE}
prepare.submission(id = test.ID, pred = pred.xgb, method = "xGB")
```

Despite the remarkable performance in the training set, the xGB model provided us a RMSE of 0.14634 when using the test set. It sounds like xGB was over-fitting to training set.

## Support vector machines with a radial kernel with cross validation

```{r,cache=TRUE}
set.seed(123)
SVM <- train(Log.SalePrice ~ ., data = training.processed,method = "svmRadial", trControl = trainControl(method = "cv", number = 10), verbose = FALSE) 
SVM
```

```{r}
log.rmse.training(pred = predict(SVM,training.processed),observed = training.processed$Log.SalePrice,method = " Support Vector Machines")
```
Support vector machines also provided some improvement beyond lasso.

### Evaluate the Support Vector Machine RMSE in test data set

```{r}
pred.svm <- exp(predict(RF, newdata = test.processed)) #Note we exponentiate the predicted values to get back into linear scale
```

Finally, prepare our submission:
```{r,eval=FALSE}
prepare.submission(id = test.ID, pred = pred.svm, method = "SVM")
```

SVM prediction gave us a RMSE of 0.14117 in the test data set, which is better than lasso.

## Using Principal Components along with Mechine Learning Algorithms

Next, let's give a try what happens when we train machine learning algorithms using the principal components of the training set:

### Gradient boosting with cross validation using Principal Components

```{r,cache=TRUE}
set.seed(123)
GBM.PCA <- train(Log.SalePrice ~ ., data = PCAtraining,method = "gbm", trControl = trainControl(method = "cv", number = 10), verbose = FALSE) 
GBM.PCA
```

Using principal components instead of the actual data slightly improved the RMSE in gradient boosting.

```{r}
log.rmse.training(pred = predict(GBM.PCA,PCAtraining),observed = training.processed$Log.SalePrice,method = " Gradient Boosting using PCs")
```

#### Evaluate the Gradient Boosting using PCs RMSE in test data set

```{r}
#Prepare principal components of the test set
library(caret)
#First get a PCA processing object
prePCA.test <- preProcess(test.processed[,-1],method = "pca")
#Generate the principal components from the training set 
PCAtest <- predict(prePCA.test,newdata = test.processed)
```


```{r}
pred.GBM.pca <- exp(predict(GBM.PCA, newdata = PCAtest)) #Note we exponentiate the predicted values to get back into linear scale
```

Finally, prepare our submission:
```{r,eval=FALSE}
prepare.submission(id = test.ID, pred = pred.GBM.pca, method = "GBM_pca")
```

This approach yields a RMSE of 0.2 in test data set, which is not as powerful as the GBM in the original data set.


### Support vector machines with a radial kernel with cross validation using principal components

```{r,cache=TRUE}
set.seed(123)
SVM.PCA <- train(Log.SalePrice ~ ., data = PCAtraining,method = "svmRadial", trControl = trainControl(method = "cv", number = 10), verbose = FALSE) 
SVM.PCA
```

In the case of SMV, using Principal components seems not to improve the RMSE:

```{r}
log.rmse.training(pred = predict(SVM.PCA,PCAtraining),observed = training.processed$Log.SalePrice,method = " Support Vector Machines using PCs")
```

###Training Random Forest algorithm with cross validation using PCs

Let's train RF algorithm to see if we can get a better RMSE:

```{r,cache=TRUE}
set.seed(123)
RF <- train(Log.SalePrice ~ ., data = PCAtraining,method = "rf", trControl = trainControl(method = "cv", number = 10)) 
RF
```

In the case of RF, using Principal components seems not to improve the RMSE:

```{r}
log.rmse.training(pred = predict(RF,PCAtraining),observed = training.processed$Log.SalePrice,method = "Random Forest using PCs")
```


# Refine the Gradient boosting model

So far the best predictions we were able to make was using the GBM model. Next, we are going to ask whether we can make this model more flexible to reduce the RMSE? Perhaps we had way more features than we needed and we were over-fitting to the data.

Let's inspect the variable importance for this model once again:

```{r}
dotPlot(varImp(GBM))
```

It looks like variable importance has already dropped significantly by the time we had 20 features in the model. Now the question is: what if we just have used the top few features to train a more flexible model:

```{r}
#Choose top10 features to train the model again
library(dplyr)

#It is hard to access the varImp elements
# This trick helps: 
col_index <- varImp(GBM)$importance %>% 
  mutate(names=row.names(.)) %>%
  arrange(-Overall)

# The feature name vector including the response variable to fetch these features from the data set:
top10.features = c("Log.SalePrice",col_index$names[1:10]) 

```


```{r,cache=TRUE}
#Train the GBM model using only these features
set.seed(123)
GBM.top10 <- train(Log.SalePrice ~ ., data = training.processed[,top10.features],method = "gbm", trControl = trainControl(method = "cv", number = 10), verbose = FALSE) 
GBM.top10
```

This gave us a model with a slightly higher RMSE in the training set:

```{r, fig.align='center'}
log.rmse.training(pred = predict(GBM.top10,training.processed[,top10.features]),observed = training.processed$Log.SalePrice,method = "GBM.top10")
```

## Estimate the RMSE in the test set using the GBM model restricted to top10 most important features:

```{r}
pred.GBM.top10 <- exp(predict(GBM.top10, newdata = test.processed[,top10.features[-1]])) #Note we exponentiate the predicted values to get back into linear scale
```

Finally, prepare our submission:
```{r,eval=FALSE}
prepare.submission(id = test.ID, pred = pred.GBM.top10 , method = "GBM_top10")
```

This gave us a RMSE of 0.14176 which is not as good as the original model.

## Scan different GBM models for reduced training RMSE

```{r,eval=FALSE}
#Only perform once
rmse.table <- data.frame(Number_of_features = 1:282, rmse = 1:282)
for(i in 1:285){
        set.seed(123)
        #Add a less important feature, one at a time, and fit new models
        features <- c("Log.SalePrice",col_index$names[1:i]) 
        GBM.temp <- train(Log.SalePrice ~ ., data = training.processed[,features],method = "gbm", trControl = trainControl(method = "cv", number = 10), verbose = FALSE)
        pred.temp <- predict(GBM.temp,training.processed[,features])
        rmse.temp <-sqrt(mean((pred.temp - training.processed$Log.SalePrice)^2))
        rmse.table$Number_of_features[i] = i
        rmse.table$rmse[i] = rmse.temp
}
saveRDS(rmse.table, file = "rmse.table.rds")
```

```{r, fig.align='center', fig.width=9}
#Find the model with minimum RMSE
rmse.table <- readRDS("rmse.table.rds")
rmse.table[which(rmse.table$rmse == min(rmse.table$rmse)),]

plot(y = rmse.table$rmse, x = rmse.table$Number_of_features, pch = 19, cex = 0.6, col = "navy",
     xlab = "RMSE", ylab = "Number of features in the GBM", main = "Scanning restricted GBM models for reduced RMSE ")
```

Note that the minimum RMSE is obtained using the model with 79 most important features. Including other features beyond this model does not further reduce the RMSE. Let's try to train and use the model formed by top79 most important features:

```{r,cache=TRUE}
top79.features = c("Log.SalePrice",col_index$names[1:79]) 
#Train the GBM model using only these features
set.seed(123)
GBM.top79 <- train(Log.SalePrice ~ ., data = training.processed[,top79.features],method = "gbm", trControl = trainControl(method = "cv", number = 10), verbose = FALSE) 
```

## Estimate the RMSE in the test set using the GBM model restricted to top50 most important features:

```{r}
pred.GBM.top79 <- exp(predict(GBM.top79, newdata = test.processed[,top79.features[-1]])) #Note we exponentiate the predicted values to get back into linear scale
```

Finally, prepare our submission:
```{r,eval=FALSE}
prepare.submission(id = test.ID, pred = pred.GBM.top79 , method = "GBM_top79")
```

This approach using the top79 most important predictors reduced the test RMSE to 0.12717. Therefore, indeed the model might become more flexible by including less features. 

# Conclusions

We have obtained a fairly good model to predict the Sale Prices in the Ames housing data set. A RMSE of 0.12717 is not trivial, but perhaps can be improved by using model ensemble methods as well as further feature engineering. I plan to revisit this problem in near future to apply and test more sophisticated approaches in order to reduce the RMSE in the test data set.
